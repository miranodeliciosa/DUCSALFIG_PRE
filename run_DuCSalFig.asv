function [] = run_DuCSalFig(sub,flag_training, flag_block)
% run_DuCSalFig(sub,flag_training, flag_isolum, flag_block)
%   runs experiment SSVEP_DuCSalFig
%       sub:            participant number
%       flag_training:  1 = do training
%       flag_isolum:    1 = do isoluminance adjustment
%       flag_block:     1 = start with block 1
%           e.g. run_FShiftGlob(99,1, 0, 1)

% Based on Scripts for FShiftBase Maria Dotzer, Christopher Gundlach, Leipzig, 2025
% Changes:  * bars stimuli in the backgorund with ChangeOnset
%           * one RDK only
%           * no fixation task 
if nargin < 3
    help run_DuCSalFig
    return
end

%% parameters
%sub = 99; flag_training = 1; flag_block = 1; 

% design 
p.sub                   = sub;                  % subject number
p.flag_block            = flag_block;           % block number to start
p.flag_training         = flag_training;        % do training

% screen
p.scr_num               = 1;                    % screen number
%p.scr_num               = 0;                    % screen number

p.scr_res               = [1920 1080];          % resolution
p.scr_refrate           = 120;                  % refresh rate in Hz (e.g. 85)
p.scr_color             = [0.05 0.05 0.05 1];      % default: [0.05 0.05 0.05 1]; ; color of screen [R G B Alpha]
p.scr_imgmultipl        = 1;                    %1: 120 Hz, 4: 480Hz

% stimplan %
p.stim.contrast        = [1 2 3 4 5 6 7 8];% contrasts (1=contrast 1 (=0), 2=contrast 2, 3= contrast 3, 4 = contrast 4 (highest))
p.stim.condition       = [1 2];           % 1 = target shape, 2=non-target shape
p.stim.eventsPerTrial   = 40;               % fixed 80 Events per Trial
p.stim.con_repeats_e    = 40;               % nEventsPerCondition 
p.stim.con_repeats_t    = 40;               
p.stim.train_trials     = 25;               % quick fix to make training shorter: presentation loop only uses first X trials; set to 0 if you dont want to cut training

% text 
p.stim.text             = {'Pause';'Drücken Sie die Leertaste, um fortzufahren.'};

%IDEA: change pre-cue event to background Event, SBA_event
% precue = SBA
p.stim.precue_event.num         = [0 0 0 0 1 2 3 4];   % ratio of no SBA-events (0) and SBA-events(1,2,3,4), 1:4  contrast; 
p.stim.precue_event.targets     = [1 2 3 4];%[1 3];     % all capture events are distractor events
p.stim.precue_event.length      = 0.125;      % length of precue-event in s              
p.stim.precue_event.min_onset   = 2.25;       % min time before precue-event onset in s
p.stim.precue_event.min_offset  = 2.25;       % min offset from precue-event end to end of trial in s

% RDK and SBA events
p.stim.event.type           = 1;                 % types of events (1 = targets only, 2 = targets + distrators) %ToDo: do we use this?
p.stim.event.length         = 0.3;              % lengt of events in s
p.stim.event.SOA_ms         = [1 4];                % min distance between events in sec
p.stim.event.min_offset     = [1 1];              % min offset from event end to end of trial in s
p.stim.event.ratio          = [1/2];              % ratio of fore- and background event number
p.stim.trialTime            = mean(p.stim.event.SOA_ms)*p.stim.eventsPerTrial;              % Preset trialtime --> can be adjusted in generate_event_onset_continuous
p.stim.frames_trialTime     = p.stim.trialTime*p.scr_refrate;


p.targ_respwin          = [200 1000];       % time window for responses in ms
% 
% p.colors                = [0.85 .85 .85 1; % define RDK color (light grey 0.7407 0.7407 0.7407)
%                             0    0.8000    0.6980 1;% Bar Col 1
%                             1.0000    0.3137         0 1;% Bar Col 2
%                             0.2745    0.4118    1.0000 1;% Bar Col 3
%                             0.7843    0.3137    1.0000 1;% Bar Col 4
%                             0.6980    0.9020         0 1]; % Bar Col 5]

% p.colors                = [0.85 .85 .85 1; % define RDK color (light grey 0.7407 0.7407 0.7407)
%                             0    0.64    0.5584 1;% Bar Col 1
%                             0.8    0.25096  0 1;% Bar Col 2
%                             0.2196    0.32944    0.80 1;% Bar Col 3
%                             0.62744    0.25096    0.8 1;% Bar Col 4
%                             0.5584    0.7216    0 1]; % Bar Col 5]

p.colors                = [0.85 .85 .85 1; % define RDK color (light grey 0.7407 0.7407 0.7407)
                            0    0.64    0.5584 1;% Bar Col 1
                            0.8    0.25096  0 1;% Bar Col 2
                            0.2196    0.32944    0.80 1;% Bar Col 3
                            0.62744    0.25096    0.8 1;% Bar Col 4
                            0.5584    0.7216    0 1]; % Bar Col 5]
                        
% RDK FOREGROUND
RDK.RDK.size             = [750 750];                % width and height of RDK in pixel; only even values [360 = 11.2°; 340 = 10.4°] -- R120 values!
RDK.RDK.centershift      = [0 0];                    % position of RDK center; x and y deviation from center in pixel
RDK.RDK.col              = [p.colors(1,:); p.scr_color(1:3) 0];% "on" and "off" color
RDK.RDK.freq             = p.scr_refrate/7;          % flicker frequency, frequency of a full "on"-"off"-cycle
RDK.RDK.mov_freq         = 120;                      % Defines how frequently the dot position is updated; 0 will adjust the update-frequency to your flicker frequency (i.e. dot position will be updated with every "on"-and every "off"-frame); 120 will update the position for every frame for 120Hz or for every 1. quadrant for 480Hz 
RDK.RDK.num              = 150;                      % number of dots 85 120
RDK.RDK.mov_speed        = 1;                        % movement speed in pixel
RDK.RDK.mov_dir          = [0 1; 0 -1; -1 0; 1 0];   % movement direction  [0 1; 0 -1; -1 0; 1 0] = up, down, left, right; !!hard coded with 4 directions in rand-scritp
RDK.RDK.dot_size         = 14;                       % 12 = 0.38°; 10 = 0.31°; 8 = 0.25°
RDK.RDK.shape            = 1;                        % 1 = square RDK; 0 = ellipse/circle RDK;

RDK.event.type              = 'globalmotion';               % event type global motion
RDK.event.duration          = p.stim.event.length;          % time of coherent motion
RDK.event.coherence         = .4;                           % percentage of coherently moving dots (0.4 in FShiftBase)
RDK.event.direction         = RDK.RDK(1).mov_dir;           % movement directions for events

% Static background bar array SBA
SBA.size                 = RDK.RDK.size+50; 
SBA.colors               = p.colors(2:6,1:3); 
SBA.numBars              = [12 12]; % must be event numbered to not be overlaid by Fixation cross
SBA.sizeBars             = [40, 15]; % siz ein pxl
SBA.freq                 = 7.5; %freq of color change on SBA
SBA.defaultAngle         = 90; % consider randomizing
SBA.event.anglesToRotate       = [5 8 10 12 14 16 20 35];
% SBA.event.anglesToRotate       = [10:5:45]; % FOR CODING 

SBA.event.condition            = [1:numel(SBA.event.anglesToRotate)];
SBA.event.barsToRotate         = cell(2,1); % bars to rotate will be assigned by shape definitions later
SBA.event.duration              = 1/SBA.freq; % duration of texture segementation event relativ to frequency of color change 
SBA.event.Shapes                = 1:5;
%SBA.event.ShapeNames            = {'triangle';'square';'diamond';'cross';'L'};
SBA.event.ShapeNames            = {'mask';'wheely';'cross';'church';'cactus'};

SBA.event.numShapes            = max(SBA.event.Shapes); % one target shape, 4 distractor shapes; 640/2/4/8 = 10 Events per distractor shape
SBA.event.targetShape           = 1; % index of target shape; 


% fixation cross % NEEDS WORK
p.crs.color                 = [0.5 0.5 0.5 1];    % color of fixation cross
p.crs.size                  = 12;               % size of fixation cross
p.crs.width                 = 2;                % width of fixation cross
p.crs.cutout                = 1;                % 1 = no dots close to fixation cross
%NOT NEEDED HERE p.crs.event                 = 1;                % pixels that disapear for event

% trigger
p.trig.rec_start        = 253;                  % trigger to start recording
p.trig.rec_stop         = 254;                  % trigger to stop recording
p.trig.tr_start         = 100;                  % trial start; main experiment
p.trig.tr_stop          = 200;                  % trial end; main experiment
p.trig.button           = 60;                   % button press

% change onset trigger: 0/100/200 for event number + 1/2/3/4 for change
% onset orientation contrast


% logfiles
p.log.path              = '/home/pc/matlab/user/sebastian/DuC_salientfigure/PreExp/logfiles/';
%p.log.path              = '/Users/sebastianwehle/Documents/MATLAB/Data_DuCSalFigPRE/logfiles/';
p.log.exp_name          = 'SSVEP_DuCSalFig';
p.log.add               = '_a';

%% check for logfile being present
filecheck=dir(sprintf('%sVP%02.0f_timing*',p.log.path,p.sub));
if ~isempty(filecheck)
    reply = input(sprintf('\nVP%02.0f existiert bereits. Datei überschreiben? [j/n]... ',p.sub),'s');
    if strcmp(reply,'j')
        p.filename = sprintf('VP%02.0f_timing',p.sub);
    else
        [temp name_ind]=max(cellfun(@(x) numel(x), {filecheck.name}));
        p.filename = sprintf('%s%s',filecheck(name_ind).name(1:end-4),p.log.add);
    end
else
    p.filename = sprintf('VP%02.0f_timing',p.sub);
end

% t.isol = {};
% % routine to check for older isoluminance adjustments
% for i_file = 1:numel(filecheck)
%     t.in = load(fullfile(filecheck(i_file).folder,filecheck(i_file).name));
%     t.datenum{i_file} = filecheck(i_file).datenum;
%     t.isol{i_file} = t.in.p.isol;
%     
% end

%% Screen init
% ps.input = struct('ScrNum',p.scr_num,'RefRate',p.scr_refrate,'PRPXres',p.scr_res,'BckGrCol',p.scr_color,'PRPXmode',2);
ps.input = struct('ScrNum',p.scr_num,'RefRate',p.scr_refrate,'PRPXres',p.scr_res,'BckGrCol',p.scr_color);

[~, ps.screensize, ps.xCenter, ps.yCenter, ps.window, ps.framerate, ps.RespDev, ps.keymap] = PTExpInit_GLSL(ps.input,0);

% define center 
ps.center = [ps.xCenter ps.yCenter];

% make fixation "cross" textures
[p.FixTex] = MakeFixationTextures(ps, p);
p.crs.rects = CenterRectOnPoint([0 0 p.crs.size p.crs.size], ps.xCenter, ps.yCenter);
Screen('DrawTexture', ps.window, p.FixTex, [], p.crs.rects);
Screen('Flip', ps.window);
%% keyboard and ports setup
KbName('UnifyKeyNames')
Buttons = [KbName('ESCAPE') KbName('Q') KbName('SPACE') KbName('j') KbName('k') KbName('m') KbName('n') KbName('1!') KbName('2@') KbName('3#')];
RestrictKeysForKbCheck(Buttons);
key.keymap=false(1,256);
key.keymap(Buttons) = true;
key.keymap_ind = find(key.keymap);
[key.ESC, key.SECRET, key.SPACE, key.YES, key.TARGET, key.DISTRACTOR, key.NO] = deal(...
    Buttons(1),Buttons(2),Buttons(3),Buttons(4),Buttons(5),Buttons(6), Buttons(7));

%% start experiment
% initialize randomization of stimulation frequencies and RDK colors ToDo: Do we want to randomize the frequencies? colors cant be randomized
rand('state',p.sub)
[RDK.RDK.col_init] = deal(RDK.RDK.col);
[RDK.RDK.freq_init] = deal(RDK.RDK.freq);

% initialize blank variables
timing = []; button_presses = []; resp = []; randmat = [];

%% no isoluminance adjustment
%% no redo initialization
%% training 
flag_trainend = 1;
%randmat.training = rand_DuCSalFig(p, RDK, SBA, 0);    % randomization


%% experiment: present each block
% randomization
rand('state',p.sub);                                    % determine randstate
randmat.experiment = rand_DuCSalFig(p, RDK, SBA, 0);    % randomization
for i_tr = 1:2 %:randmat.experiment.totaltrials % i_bl = "Trial"
    % start experiment
    [timing.experiment{i_tr},button_presses.experiment{i_tr},resp.experiment{i_tr}] = ...
        pres_DuCSalFig(p, ps, key, RDK, SBA, randmat.experiment, i_tr,0);
    % save logfiles
    save(sprintf('%s%s',p.log.path,p.filename),'timing','button_presses','resp','randmat','p', 'RDK', 'SBA')       
    pres_feedback_DuCSalFig(resp.experiment{i_tr},p,ps, key )    
end

fprintf(1,'\n\nENDE\n')
sca;

end 